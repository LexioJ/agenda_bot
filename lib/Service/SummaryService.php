<?php

declare(strict_types=1);
/**
 * SPDX-FileCopyrightText: 2025 Agenda Bot Contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */

namespace OCA\AgendaBot\Service;

use OCA\AgendaBot\AppInfo\Application;
use OCA\AgendaBot\Model\LogEntry;
use OCA\AgendaBot\Model\LogEntryMapper;
use OCP\AppFramework\Utility\ITimeFactory;
use OCP\IConfig;

class SummaryService {

	public function __construct(
		protected LogEntryMapper $logEntryMapper,
		protected ITimeFactory $timeFactory,
		protected IConfig $config,
		protected AgendaService $agendaService,
	) {
	}

	public function processMessage(string $message, array $data): bool {
		$token = $data['target']['id'] ?? '';
		if (!$token) {
			return false;
		}

		// Note: Agenda items are now handled directly in BotInvokeListener
		// This method only handles general message logging

		// Log as a general message
		$entry = new LogEntry();
		$entry->setServer('local');
		$entry->setToken($token);
		$entry->setType(LogEntry::TYPE_MESSAGE);
		$entry->setDetails(json_encode([
			'message' => $message,
			'actor_type' => $data['actor']['type'] ?? 'unknown',
			'actor_id' => $data['actor']['id'] ?? 'unknown',
			'message_type' => 'comment'
		], JSON_THROW_ON_ERROR));
		$this->logEntryMapper->insert($entry);

		return true;
	}

	public function generateAgendaSummary(string $token, string $conversation): ?array {
		$agendaData = $this->agendaService->exportAgenda($token);
		
		if ($agendaData['total'] === 0) {
			return null;
		}

		$summary = "### üìã Meeting Agenda Summary\n\n";
		$summary .= "**Topic:** " . $conversation . "\n";
		$summary .= "**Total Agenda Items:** " . $agendaData['total'] . "\n";
		
		// Enhanced completed section with timing percentages
		if ($agendaData['completed'] > 0) {
			$timingStats = $agendaData['timing_stats'];
			$summary .= sprintf("**Completed:** %d (%d%% üëç / %d%% ‚è∞)\n", 
				$agendaData['completed'],
				$timingStats['in_time_percentage'],
				$timingStats['overdue_percentage']
			);
		} else {
			$summary .= "**Completed:** " . $agendaData['completed'] . "\n";
		}
		
		$summary .= "**Remaining:** " . $agendaData['incomplete'] . "\n\n";

		if (!empty($agendaData['completed_items_with_timing'])) {
			$summary .= "#### ‚úÖ Completed Items\n";
			foreach ($agendaData['completed_items_with_timing'] as $item) {
				$plannedDuration = $item['duration'];
				$timeDiff = $item['time_diff'];
				$isOverdue = $item['is_overdue'];
				
				// Format timing display: planned+diff or planned-diff
				if ($timeDiff > 0) {
					$timingDisplay = sprintf("(%d+%d min)", $plannedDuration, $timeDiff);
					$statusIcon = " ‚è∞";
				} elseif ($timeDiff < 0) {
					$timingDisplay = sprintf("(%d%d min)", $plannedDuration, $timeDiff); // negative diff
					$statusIcon = " üëç";
				} else {
					$timingDisplay = sprintf("(%d min)", $plannedDuration);
					$statusIcon = " üëç";
				}
				
				$summary .= $item['position'] . ". " . $item['title'] . " " . $timingDisplay . $statusIcon . "\n";
			}
			$summary .= "\n";
		}

		if (!empty($agendaData['incomplete_items'])) {
			$summary .= "#### ‚è∏Ô∏è Remaining Items\n";
			foreach ($agendaData['incomplete_items'] as $item) {
				$summary .= $item['position'] . ". " . $item['title'] . " (" . $item['duration'] . " min)\n";
			}
			$summary .= "\n";
		}

		$summary .= "---\n";
		$summary .= "_Generated by Agenda bot_";
		
		// Add cleanup question if there are completed items
		if ($agendaData['completed'] > 0) {
			$summary .= "\n\nüßπ **Remove completed items from agenda?**\n";
			$summary .= "*Moderators/Owners: Reply with 'agenda cleanup'*";
		}

		return [
			'summary' => $summary,
			'agenda_data' => $agendaData,
		];
	}

	public function logAttendee(string $token, string $attendee): void {
		$entry = new LogEntry();
		$entry->setServer('local');
		$entry->setToken($token);
		$entry->setType(LogEntry::TYPE_ATTENDEE);
		$entry->setDetails($attendee);
		$this->logEntryMapper->insert($entry);
	}

	public function logCallStart(string $token): void {
		$entry = new LogEntry();
		$entry->setServer('local');
		$entry->setToken($token);
		$entry->setType(LogEntry::TYPE_START);
		$entry->setDetails((string)$this->timeFactory->now()->getTimestamp());
		$this->logEntryMapper->insert($entry);
	}

	public function logCallEnd(string $token): void {
		$entry = new LogEntry();
		$entry->setServer('local');
		$entry->setToken($token);
		$entry->setType(LogEntry::TYPE_END);
		$entry->setDetails((string)$this->timeFactory->now()->getTimestamp());
		$this->logEntryMapper->insert($entry);
	}
}
