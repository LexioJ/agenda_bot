<?php

declare(strict_types=1);
/**
 * SPDX-FileCopyrightText: 2025 Agenda Bot Contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */

namespace OCA\AgendaBot\Service;

use OCA\AgendaBot\AppInfo\Application;
use OCA\AgendaBot\Model\LogEntry;
use OCA\AgendaBot\Model\LogEntryMapper;
use OCP\AppFramework\Utility\ITimeFactory;
use OCP\IConfig;
use OCP\L10N\IFactory;

class SummaryService {

	private $l;

	public function __construct(
		protected LogEntryMapper $logEntryMapper,
		protected ITimeFactory $timeFactory,
		protected IConfig $config,
		protected AgendaService $agendaService,
		protected IFactory $l10nFactory,
	) {
		$this->l = $l10nFactory->get('agenda_bot');
	}

	public function processMessage(string $message, array $data): bool {
		$token = $data['target']['id'] ?? '';
		if (!$token) {
			return false;
		}

		// Note: Agenda items are now handled directly in BotInvokeListener
		// This method only handles general message logging

		// Log as a general message
		$entry = new LogEntry();
		$entry->setServer('local');
		$entry->setToken($token);
		$entry->setType(LogEntry::TYPE_MESSAGE);
		$entry->setDetails(json_encode([
			'message' => $message,
			'actor_type' => $data['actor']['type'] ?? 'unknown',
			'actor_id' => $data['actor']['id'] ?? 'unknown',
			'message_type' => 'comment'
		], JSON_THROW_ON_ERROR));
		$this->logEntryMapper->insert($entry);

		return true;
	}

	public function generateAgendaSummary(string $token, string $conversation, string $lang = 'en'): ?array {
		$l = $this->l10nFactory->get(Application::APP_ID, $lang);
		$agendaData = $this->agendaService->exportAgenda($token);
		
		if ($agendaData['total'] === 0) {
			return null;
		}

		$summary = "### 📋 " . $l->t('Meeting Agenda Summary') . "\n\n";
		$summary .= "**" . $l->t('Topic:') . "** " . $conversation . "\n";
		$summary .= "**" . $l->t('Total Agenda Items:') . "** " . $agendaData['total'] . "\n";
		
		// Enhanced completed section with timing percentages
		if ($agendaData['completed'] > 0) {
			$timingStats = $agendaData['timing_stats'];
			$summary .= "**" . $l->t('Completed:') . "** " . $l->t('%d (%d%% 👍 / %d%% ⏰)', [
				$agendaData['completed'],
				$timingStats['in_time_percentage'],
				$timingStats['overdue_percentage']
			]) . "\n";
		} else {
			$summary .= "**" . $l->t('Completed:') . "** " . $agendaData['completed'] . "\n";
		}
		
		$summary .= "**" . $l->t('Remaining:') . "** " . $agendaData['incomplete'] . "\n\n";

		if (!empty($agendaData['completed_items_with_timing'])) {
			$summary .= "#### ✅ " . $l->t('Completed Items') . "\n";
			foreach ($agendaData['completed_items_with_timing'] as $item) {
				$plannedDuration = $item['duration'];
				$timeDiff = $item['time_diff'];
				$isOverdue = $item['is_overdue'];
				
				// Format timing display: planned+diff or planned-diff
				if ($timeDiff > 0) {
					$timingDisplay = $l->t('(%d+%d min)', [$plannedDuration, $timeDiff]);
					$statusIcon = " " . $this->l->t('Time Warning');
				} elseif ($timeDiff < 0) {
					$timingDisplay = $l->t('(%d%d min)', [$plannedDuration, $timeDiff]); // negative diff
					$statusIcon = " 👍";
				} else {
					$timingDisplay = $l->t('(%d min)', [$plannedDuration]);
					$statusIcon = " 👍";
				}
				
				$summary .= $item['position'] . ". " . $item['title'] . " " . $timingDisplay . $statusIcon . "\n";
			}
			$summary .= "\n";
		}

		if (!empty($agendaData['incomplete_items'])) {
			$summary .= "#### ⏸️ " . $l->t('Remaining Items') . "\n";
			foreach ($agendaData['incomplete_items'] as $item) {
				$summary .= $item['position'] . ". " . $item['title'] . " (" . $item['duration'] . " " . $l->t('min') . ")\n";
			}
			$summary .= "\n";
		}

		$summary .= "---\n";
		$summary .= "_" . $l->t('Generated by Agenda bot') . "_";
		
		// Add cleanup question if there are completed items
		if ($agendaData['completed'] > 0) {
			$summary .= "\n\n🧹 **" . $l->t('Remove completed items from agenda?') . "**\n";
			$summary .= "*" . $l->t("Moderators/Owners: Reply with 'agenda cleanup'") . "*";
		}

		return [
			'summary' => $summary,
			'agenda_data' => $agendaData,
		];
	}

	public function logAttendee(string $token, string $attendee): void {
		$entry = new LogEntry();
		$entry->setServer('local');
		$entry->setToken($token);
		$entry->setType(LogEntry::TYPE_ATTENDEE);
		$entry->setDetails($attendee);
		$this->logEntryMapper->insert($entry);
	}

	public function logCallStart(string $token): void {
		$entry = new LogEntry();
		$entry->setServer('local');
		$entry->setToken($token);
		$entry->setType(LogEntry::TYPE_START);
		$entry->setDetails((string)$this->timeFactory->now()->getTimestamp());
		$this->logEntryMapper->insert($entry);
	}

	public function logCallEnd(string $token): void {
		$entry = new LogEntry();
		$entry->setServer('local');
		$entry->setToken($token);
		$entry->setType(LogEntry::TYPE_END);
		$entry->setDetails((string)$this->timeFactory->now()->getTimestamp());
		$this->logEntryMapper->insert($entry);
	}
}
